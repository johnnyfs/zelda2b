#!/usr/bin/env python3
"""
json2asm.py — Convert JSON data tables to ca65 assembly .byte/.word data.

Supports:
- Enemy stat tables (HP, damage, speed, behavior, drops)
- Palette definitions (4 palettes of 4 colors)
- Metatile definitions (4 tile indices + attributes per metatile)
- Generic byte/word arrays

Input:  JSON file with a specific schema
Output: ca65 assembly source with .byte/.word directives

Usage:
  python3 json2asm.py enemies.json enemies.s --type enemies
  python3 json2asm.py palettes.json palettes.s --type palettes
  python3 json2asm.py metatiles.json metatiles.s --type metatiles
  python3 json2asm.py data.json data.s --type raw
"""

import argparse
import json
import sys
from pathlib import Path


def format_byte(val: int) -> str:
    """Format a byte value as ca65 hex literal."""
    return f"${val:02X}"


def format_word(val: int) -> str:
    """Format a 16-bit word value as ca65 hex literal."""
    return f"${val:04X}"


def emit_header(name: str, source_file: str) -> str:
    """Emit a standard file header comment."""
    return (
        f"; ==========================================================\n"
        f"; {name} — auto-generated by json2asm.py\n"
        f"; Source: {source_file}\n"
        f"; DO NOT EDIT — regenerate from JSON source\n"
        f"; ==========================================================\n\n"
    )


def convert_enemies(data: dict) -> str:
    """Convert enemy stat table JSON to ca65 assembly."""
    out = []
    enemies = data["enemies"]

    # Emit parallel arrays (SoA layout, better for NES random access)
    fields = ["hp", "damage", "speed", "behavior", "drop_table"]
    labels = {
        "hp": "enemy_hp_table",
        "damage": "enemy_damage_table",
        "speed": "enemy_speed_table",
        "behavior": "enemy_behavior_table",
        "drop_table": "enemy_drop_table",
    }

    # Name table as comment reference
    out.append("; Enemy index reference:")
    for i, enemy in enumerate(enemies):
        out.append(f";   {i} = {enemy['name']}")
    out.append(f"; Total: {len(enemies)} enemies")
    out.append("")

    for field in fields:
        label = labels[field]
        out.append(f".export {label}")
        out.append(f"{label}:")
        for enemy in enemies:
            val = enemy.get(field, 0)
            out.append(f"    .byte {format_byte(val)}  ; {enemy['name']}")
        out.append("")

    return "\n".join(out)


def convert_palettes(data: dict) -> str:
    """Convert palette definitions JSON to ca65 assembly."""
    out = []

    for group_name, palettes in data.items():
        out.append(f".export {group_name}")
        out.append(f"{group_name}:")
        for i, pal in enumerate(palettes):
            colors = ", ".join(format_byte(c) for c in pal)
            out.append(f"    .byte {colors}  ; palette {i}")
        out.append("")

    return "\n".join(out)


def convert_metatiles(data: dict) -> str:
    """Convert metatile definitions JSON to ca65 assembly.

    Each metatile = 4 CHR tile indices (TL, TR, BL, BR) + 1 attribute byte.
    """
    out = []
    metatiles = data["metatiles"]
    name = data.get("name", "metatile_defs")

    out.append(f"; Metatile definitions: {len(metatiles)} entries")
    out.append(f"; Format: TL, TR, BL, BR tile indices + attribute byte")
    out.append(f"; Attribute byte: bits 0-1 = palette, bit 2 = solid, bit 3 = water, etc.")
    out.append("")

    # Parallel arrays for efficient NES access
    arrays = {
        f"{name}_tl": [],
        f"{name}_tr": [],
        f"{name}_bl": [],
        f"{name}_br": [],
        f"{name}_attr": [],
    }

    for i, mt in enumerate(metatiles):
        arrays[f"{name}_tl"].append((mt["tl"], mt.get("name", f"metatile_{i}")))
        arrays[f"{name}_tr"].append((mt["tr"], mt.get("name", f"metatile_{i}")))
        arrays[f"{name}_bl"].append((mt["bl"], mt.get("name", f"metatile_{i}")))
        arrays[f"{name}_br"].append((mt["br"], mt.get("name", f"metatile_{i}")))
        arrays[f"{name}_attr"].append((mt.get("attr", 0), mt.get("name", f"metatile_{i}")))

    for label, values in arrays.items():
        out.append(f".export {label}")
        out.append(f"{label}:")
        for val, comment in values:
            out.append(f"    .byte {format_byte(val)}  ; {comment}")
        out.append("")

    return "\n".join(out)


def convert_raw(data: dict) -> str:
    """Convert a generic byte/word array JSON to ca65 assembly."""
    out = []

    for label, entry in data.items():
        dtype = entry.get("type", "byte")
        values = entry["values"]
        out.append(f".export {label}")
        out.append(f"{label}:")
        if dtype == "word":
            vals = ", ".join(format_word(v) for v in values)
            out.append(f"    .word {vals}")
        else:
            # Emit in rows of 16
            for i in range(0, len(values), 16):
                chunk = values[i:i+16]
                vals = ", ".join(format_byte(v) for v in chunk)
                out.append(f"    .byte {vals}")
        out.append("")

    return "\n".join(out)


def main():
    parser = argparse.ArgumentParser(description="Convert JSON data tables to ca65 assembly")
    parser.add_argument("input", help="Input JSON file")
    parser.add_argument("output", help="Output .s assembly file")
    parser.add_argument("--type", choices=["enemies", "palettes", "metatiles", "raw"],
                        required=True, help="Data type to convert")
    parser.add_argument("--segment", type=str, default=None,
                        help="Segment name to place data in (e.g., PRG_FIXED_C)")
    args = parser.parse_args()

    data = json.loads(Path(args.input).read_text())

    converters = {
        "enemies": convert_enemies,
        "palettes": convert_palettes,
        "metatiles": convert_metatiles,
        "raw": convert_raw,
    }

    header = emit_header(args.type.title() + " Data", args.input)
    body = converters[args.type](data)

    segment_directive = ""
    if args.segment:
        segment_directive = f'.segment "{args.segment}"\n\n'

    output = header + segment_directive + body
    Path(args.output).write_text(output)
    print(f"OK: Generated {args.output} ({len(output)} chars)")


if __name__ == "__main__":
    main()
