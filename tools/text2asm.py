#!/usr/bin/env python3
"""
text2asm.py — Convert dialog JSON to ca65 assembly for NES text rendering.

NES text encoding:
- Characters are mapped to font tile indices in CHR ROM.
- Each string is null-terminated ($00).
- Newline = $FE. End of dialog = $FF.
- Characters A-Z map to tile indices $41-$5A (matching ASCII layout in font).
- Numbers 0-9 map to $30-$39.
- Space = $20, ! = $21, ? = $3F, . = $2E, , = $2C, ' = $27, - = $2D

Usage:
  python3 text2asm.py dialog.json dialog.s
"""

import argparse
import json
import sys
from pathlib import Path


# NES tile mapping for printable characters
CHAR_MAP = {}
# Letters A-Z
for i, c in enumerate("ABCDEFGHIJKLMNOPQRSTUVWXYZ"):
    CHAR_MAP[c] = 0x41 + i
# Numbers 0-9
for i, c in enumerate("0123456789"):
    CHAR_MAP[c] = 0x30 + i
# Punctuation
CHAR_MAP[' '] = 0x20
CHAR_MAP['!'] = 0x21
CHAR_MAP['?'] = 0x3F
CHAR_MAP['.'] = 0x2E
CHAR_MAP[','] = 0x2C
CHAR_MAP["'"] = 0x27
CHAR_MAP['-'] = 0x2D
CHAR_MAP[':'] = 0x3A

NEWLINE_CODE = 0xFE
END_DIALOG_CODE = 0xFF


def encode_text(text: str) -> list:
    """Encode a string to NES tile indices."""
    result = []
    for ch in text.upper():
        if ch in CHAR_MAP:
            result.append(CHAR_MAP[ch])
        else:
            result.append(0x20)  # Unknown → space
    return result


def encode_dialog(lines: list) -> list:
    """Encode a multi-line dialog to NES format."""
    result = []
    for i, line in enumerate(lines):
        result.extend(encode_text(line))
        if i < len(lines) - 1:
            result.append(NEWLINE_CODE)
    result.append(END_DIALOG_CODE)
    return result


def format_bytes(data: list, per_line: int = 16) -> str:
    """Format a list of bytes as ca65 .byte directives."""
    lines = []
    for i in range(0, len(data), per_line):
        chunk = data[i:i+per_line]
        vals = ", ".join(f"${b:02X}" for b in chunk)
        lines.append(f"    .byte {vals}")
    return "\n".join(lines)


def main():
    parser = argparse.ArgumentParser(description="Convert dialog JSON to ca65 assembly")
    parser.add_argument("input", help="Input JSON file")
    parser.add_argument("output", help="Output .s assembly file")
    parser.add_argument("--segment", type=str, default="PRG_FIXED_C",
                        help="Segment name (default: PRG_FIXED_C)")
    args = parser.parse_args()

    data = json.loads(Path(args.input).read_text())
    out = []

    out.append("; ==========================================================")
    out.append("; Dialog Text Data — auto-generated by text2asm.py")
    out.append(f"; Source: {args.input}")
    out.append("; DO NOT EDIT — regenerate from JSON source")
    out.append("; Encoding: tile indices. $FE=newline, $FF=end of dialog")
    out.append("; ==========================================================")
    out.append("")
    out.append(f'.segment "{args.segment}"')
    out.append("")

    total_bytes = 0

    # NPC dialogs
    if "npcs" in data:
        for town, dialogs in data["npcs"].items():
            out.append(f"; --- {town} ---")
            for dialog in dialogs:
                label = f"text_{dialog['id']}"
                encoded = encode_dialog(dialog["lines"])
                total_bytes += len(encoded)
                out.append(f".export {label}")
                out.append(f"{label}:")
                out.append(format_bytes(encoded))
                out.append("")

    # Signs
    if "signs" in data:
        out.append("; --- Signs ---")
        for sign in data["signs"]:
            label = f"text_{sign['id']}"
            encoded = encode_dialog(sign["lines"])
            total_bytes += len(encoded)
            out.append(f".export {label}")
            out.append(f"{label}:")
            out.append(format_bytes(encoded))
            out.append("")

    # Item pickups
    if "items" in data:
        out.append("; --- Item Pickups ---")
        for item in data["items"]:
            label = f"text_{item['id']}"
            encoded = encode_dialog(item["lines"])
            total_bytes += len(encoded)
            out.append(f".export {label}")
            out.append(f"{label}:")
            out.append(format_bytes(encoded))
            out.append("")

    # Story text
    if "story" in data:
        out.append("; --- Story ---")
        for entry in data["story"]:
            label = f"text_{entry['id']}"
            encoded = encode_dialog(entry["lines"])
            total_bytes += len(encoded)
            out.append(f".export {label}")
            out.append(f"{label}:")
            out.append(format_bytes(encoded))
            out.append("")

    # String table (pointer table for indexed lookup)
    out.append("; --- String Pointer Table ---")
    all_labels = []
    if "npcs" in data:
        for town, dialogs in data["npcs"].items():
            for dialog in dialogs:
                all_labels.append(f"text_{dialog['id']}")
    if "signs" in data:
        for sign in data["signs"]:
            all_labels.append(f"text_{sign['id']}")
    if "items" in data:
        for item in data["items"]:
            all_labels.append(f"text_{item['id']}")
    if "story" in data:
        for entry in data["story"]:
            all_labels.append(f"text_{entry['id']}")

    out.append(f"; Total: {len(all_labels)} strings, {total_bytes} bytes")
    out.append(f".export text_table_lo, text_table_hi")
    out.append("text_table_lo:")
    for label in all_labels:
        out.append(f"    .byte <{label}")
    out.append("text_table_hi:")
    for label in all_labels:
        out.append(f"    .byte >{label}")
    out.append("")

    output = "\n".join(out)
    Path(args.output).write_text(output)
    print(f"OK: {len(all_labels)} strings, {total_bytes} text bytes → {args.output}")


if __name__ == "__main__":
    main()
