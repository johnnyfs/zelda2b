#!/usr/bin/env python3
"""
text2asm.py — Convert dialog JSON to ca65 assembly for NES text rendering.

NES text encoding:
- Characters are mapped to font tile indices in CHR ROM.
- Each string is null-terminated ($00).
- Newline = $FE. End of dialog = $FF.
- Characters A-Z map to tile indices $41-$5A (matching ASCII layout in font).
- Numbers 0-9 map to $30-$39.
- Space = $20, ! = $21, ? = $3F, . = $2E, , = $2C, ' = $27, - = $2D

Usage:
  python3 text2asm.py dialog.json dialog.s
"""

import argparse
import json
import sys
from pathlib import Path

CHAR_MAP = {}
for i, c in enumerate("ABCDEFGHIJKLMNOPQRSTUVWXYZ"):
    CHAR_MAP[c] = 0x41 + i
for i, c in enumerate("0123456789"):
    CHAR_MAP[c] = 0x30 + i
CHAR_MAP[' '] = 0x20
CHAR_MAP['!'] = 0x21
CHAR_MAP['?'] = 0x3F
CHAR_MAP['.'] = 0x2E
CHAR_MAP[','] = 0x2C
CHAR_MAP["'"] = 0x27
CHAR_MAP['-'] = 0x2D
CHAR_MAP[':'] = 0x3A

NEWLINE_CODE = 0xFE
END_DIALOG_CODE = 0xFF


def encode_text(text):
    return [CHAR_MAP.get(ch, 0x20) for ch in text.upper()]


def encode_dialog(lines):
    result = []
    for i, line in enumerate(lines):
        result.extend(encode_text(line))
        if i < len(lines) - 1:
            result.append(NEWLINE_CODE)
    result.append(END_DIALOG_CODE)
    return result


def format_bytes(data, per_line=16):
    lines = []
    for i in range(0, len(data), per_line):
        chunk = data[i:i+per_line]
        vals = ", ".join(f"${b:02X}" for b in chunk)
        lines.append(f"    .byte {vals}")
    return "\n".join(lines)


def main():
    parser = argparse.ArgumentParser(description="Convert dialog JSON to ca65 assembly")
    parser.add_argument("input", help="Input JSON file")
    parser.add_argument("output", help="Output .s assembly file")
    parser.add_argument("--segment", type=str, default="PRG_FIXED_C",
                        help="Segment name (default: PRG_FIXED_C)")
    args = parser.parse_args()

    data = json.loads(Path(args.input).read_text())
    out = []
    out.append("; ==========================================================")
    out.append("; Dialog Text Data — auto-generated by text2asm.py")
    out.append(f"; Source: {args.input}")
    out.append("; DO NOT EDIT — regenerate from JSON source")
    out.append("; Encoding: tile indices. $FE=newline, $FF=end of dialog")
    out.append("; ==========================================================")
    out.append("")
    out.append(f'.segment "{args.segment}"')
    out.append("")

    total_bytes = 0
    all_labels = []

    if "npcs" in data:
        for town, dialogs in data["npcs"].items():
            out.append(f"; --- {town} ---")
            for dialog in dialogs:
                label = f"text_{dialog['id']}"
                encoded = encode_dialog(dialog["lines"])
                total_bytes += len(encoded)
                all_labels.append(label)
                out.append(f".export {label}")
                out.append(f"{label}:")
                out.append(format_bytes(encoded))
                out.append("")

    for section in ["signs", "items", "story"]:
        if section in data:
            out.append(f"; --- {section.title()} ---")
            for entry in data[section]:
                label = f"text_{entry['id']}"
                encoded = encode_dialog(entry["lines"])
                total_bytes += len(encoded)
                all_labels.append(label)
                out.append(f".export {label}")
                out.append(f"{label}:")
                out.append(format_bytes(encoded))
                out.append("")

    out.append(f"; --- String Pointer Table ({len(all_labels)} strings, {total_bytes} bytes) ---")
    out.append(".export text_table_lo, text_table_hi")
    out.append("text_table_lo:")
    for label in all_labels:
        out.append(f"    .byte <{label}")
    out.append("text_table_hi:")
    for label in all_labels:
        out.append(f"    .byte >{label}")
    out.append("")

    Path(args.output).write_text("\n".join(out))
    print(f"OK: {len(all_labels)} strings, {total_bytes} text bytes → {args.output}")


if __name__ == "__main__":
    main()
