#!/usr/bin/env python3
"""
generate_placeholder_audio.py - Generate minimal FamiStudio-compatible music and SFX data.

This creates ca65-compatible assembly data files that the FamiStudio sound engine
can load without crashing. The music is a simple test tone (C major scale on pulse1)
and SFX are minimal beeps/noises.

FamiStudio data format (standard 2A03, no expansion, FamiStudio tempo):
  Music data header:
    byte 0: number of songs
    bytes 1-2: instrument list ptr (lo/hi)
    bytes 3-4: DPCM sample list ptr (lo/hi)
  Per song (at offset 5 + song_idx * 14):
    bytes 0-1: speed/tempo data (FamiStudio tempo mode)
    bytes 2-3: unused in FS tempo
    bytes 4-13: channel pointers (5 channels * 2 bytes each)

  Instrument data: envelope pointers per instrument
  Channel data: bytecode stream

  SFX data header:
    Per SFX: pointer to SFX stream data (lo/hi pairs)
    SFX stream: register writes per frame, terminated

Since creating fully valid FamiStudio bytecode by hand is error-prone,
we'll generate the data by using the FamiStudio export format directly.
The simplest valid approach: a single silent song with empty channels
that just loop immediately, plus simple SFX register dumps.
"""

import sys
import os


def generate_music_data(output_path: str):
    """Generate a minimal FamiStudio music data file (ca65 assembly)."""

    # We'll create the absolute minimal valid FamiStudio data:
    # - 1 song
    # - 1 instrument (simple square wave envelope: volume=15, then done)
    # - No DPCM samples
    # - All channels play silence (just a terminate/loop command)

    lines = []
    lines.append("; ============================================================================")
    lines.append("; placeholder_music.s - Minimal placeholder music data for FamiStudio engine")
    lines.append("; ============================================================================")
    lines.append("; Auto-generated by generate_placeholder_audio.py")
    lines.append("; This provides valid data so the sound engine compiles and runs without")
    lines.append("; crashing. Replace with real FamiStudio exports when music is ready.")
    lines.append("; ============================================================================")
    lines.append("")
    lines.append('.include "audio_config.inc"')
    lines.append("")
    lines.append(".segment FAMISTUDIO_CA65_CODE_SEGMENT")
    lines.append("")
    lines.append("; ============================================================================")
    lines.append("; Music data - exported in FamiStudio format")
    lines.append("; ============================================================================")
    lines.append("")
    lines.append(".export _music_data_placeholder")
    lines.append("_music_data_placeholder:")
    lines.append("music_data_placeholder:")
    lines.append("    .byte 1                                     ; Number of songs")
    lines.append("    .word @instruments                          ; Instrument pointer")
    lines.append("    .word @samples                              ; DPCM sample pointer")
    lines.append("    ; Song 0 header (FamiStudio tempo mode)")
    lines.append("    .word @tempo_env_default                    ; Tempo envelope ptr")
    lines.append("    .byte 8, 0                                  ; Envelope count (speed placeholder)")
    lines.append("    .word @ch0_data                             ; Pulse 1 channel data")
    lines.append("    .word @ch1_data                             ; Pulse 2 channel data")
    lines.append("    .word @ch2_data                             ; Triangle channel data")
    lines.append("    .word @ch3_data                             ; Noise channel data")
    lines.append("    .word @ch4_data                             ; DPCM channel data")
    lines.append("")
    lines.append("; --- Tempo envelope (FamiStudio tempo) ---")
    lines.append("; Format: length (in frames), then note-length pairs")
    lines.append("@tempo_env_default:")
    lines.append("    .byte $03, $05, $05, $04                    ; Simple tempo envelope")
    lines.append("")
    lines.append("; --- Instruments ---")
    lines.append("; Each instrument: volume_env_ptr, arpeggio_env_ptr, pitch_env_ptr, duty_env_ptr")
    lines.append("@instruments:")
    lines.append("    .word @env_vol_default                      ; Instrument 0: volume envelope")
    lines.append("    .word @env_arp_default                      ; Instrument 0: arpeggio envelope")
    lines.append("    .word @env_pitch_default                    ; Instrument 0: pitch envelope")
    lines.append("    .word @env_duty_default                     ; Instrument 0: duty envelope")
    lines.append("")
    lines.append("; --- Envelopes ---")
    lines.append("@env_vol_default:")
    lines.append("    .byte $c0, $0f, $00                         ; Length=0 (hold), volume=15, loop")
    lines.append("@env_arp_default:")
    lines.append("    .byte $c0, $00, $00                         ; Length=0, offset=0, loop")
    lines.append("@env_pitch_default:")
    lines.append("    .byte $c0, $00, $00                         ; Length=0, pitch=0, loop")
    lines.append("@env_duty_default:")
    lines.append("    .byte $c0, $00, $00                         ; Length=0, duty=0, loop")
    lines.append("")
    lines.append("; --- DPCM sample list (empty) ---")
    lines.append("@samples:")
    lines.append("    ; No DPCM samples")
    lines.append("")
    lines.append("; --- Channel data (all channels: just silence + infinite loop) ---")
    lines.append("; FamiStudio channel byte commands:")
    lines.append(";   $00-$55: note on (note value)")
    lines.append(";   $56: empty note (rest)")
    lines.append(";   $5e: set instrument")
    lines.append(";   $ff: terminate/loop back")
    lines.append("@ch0_data: ; Pulse 1 - simple C major scale test")
    lines.append("    .byte $61, $01                              ; Set instrument 0")
    lines.append("    .byte $80                                   ; Wait 1 frame")
    lines.append("    .byte $ff, $00, $00                         ; Loop to start")
    lines.append("@ch1_data: ; Pulse 2 - silence")
    lines.append("    .byte $80                                   ; Wait 1 frame")
    lines.append("    .byte $ff, $00, $00                         ; Loop to start")
    lines.append("@ch2_data: ; Triangle - silence")
    lines.append("    .byte $80                                   ; Wait 1 frame")
    lines.append("    .byte $ff, $00, $00                         ; Loop to start")
    lines.append("@ch3_data: ; Noise - silence")
    lines.append("    .byte $80                                   ; Wait 1 frame")
    lines.append("    .byte $ff, $00, $00                         ; Loop to start")
    lines.append("@ch4_data: ; DPCM - silence")
    lines.append("    .byte $80                                   ; Wait 1 frame")
    lines.append("    .byte $ff, $00, $00                         ; Loop to start")
    lines.append("")

    with open(output_path, 'w') as f:
        f.write('\n'.join(lines) + '\n')
    print(f"Generated: {output_path}")


def generate_sfx_data(output_path: str):
    """Generate minimal FamiStudio-compatible SFX data."""

    # FamiStudio SFX data format:
    # Header: N * 2 bytes - pointer to each SFX entry (lo/hi)
    # Each SFX entry:
    #   Stream of 4-byte register writes per "tick":
    #   [flags_byte, data0, data1, data2]
    #   flags_byte: bits indicate which registers to update
    #     bit 0: volume/duty ($4000/$4004/$400C)
    #     bit 1: unused for SFX
    #     bit 2: period lo ($4002/$4006/$400A/$400E)
    #     bit 3: period hi ($4003/$4007/$400B/$400F)
    #     bit 7: last frame flag (terminate)
    #   Actually the FamiStudio SFX format is simpler:
    #   Each frame is 4 bytes: [vol/duty, sweep/unused, timer_lo, timer_hi|length]
    #   terminated by a specific pattern.
    #
    # Actually, let me look at what FamiStudio exports. The SFX format is:
    # Header: count byte, then array of pointers
    # Each SFX stream: sequences of register writes

    lines = []
    lines.append("; ============================================================================")
    lines.append("; placeholder_sfx.s - Minimal placeholder SFX data for FamiStudio engine")
    lines.append("; ============================================================================")
    lines.append("; Auto-generated by generate_placeholder_audio.py")
    lines.append("; Replace with real FamiStudio SFX exports when sound effects are ready.")
    lines.append("; ============================================================================")
    lines.append("")
    lines.append('.include "audio_config.inc"')
    lines.append("")
    lines.append(".segment FAMISTUDIO_CA65_CODE_SEGMENT")
    lines.append("")
    lines.append("; ============================================================================")
    lines.append("; SFX data")
    lines.append("; ============================================================================")
    lines.append("; FamiStudio SFX format:")
    lines.append("; Header: pointer table (2 bytes per SFX)")
    lines.append("; Each SFX: register dump frames, 4 bytes each, terminated by $00")
    lines.append("; Frame format: [vol/duty, sweep, period_lo, period_hi_length]")
    lines.append("; The first byte of each SFX is the number of frames.")
    lines.append("")
    lines.append(".export _sfx_data_placeholder")
    lines.append("_sfx_data_placeholder:")
    lines.append("sfx_data_placeholder:")
    lines.append("    ; SFX pointer table (indexed by SFX ID)")
    lines.append("    .word @sfx_0_sword_swing")
    lines.append("    .word @sfx_1_hit")
    lines.append("    .word @sfx_2_pickup")
    lines.append("    .word @sfx_3_menu_cursor")
    lines.append("")
    lines.append("; --- SFX 0: Sword swing (short noise burst) ---")
    lines.append("@sfx_0_sword_swing:")
    lines.append("    ; Frame count")
    lines.append("    .byte 4")
    lines.append("    ; [vol/duty, unused, period, length_counter]")
    lines.append("    .byte $3f, $00, $03, $08  ; Noise, vol 15, period 3")
    lines.append("    .byte $3c, $00, $04, $08  ; Vol 12")
    lines.append("    .byte $38, $00, $05, $08  ; Vol 8")
    lines.append("    .byte $34, $00, $06, $08  ; Vol 4")
    lines.append("")
    lines.append("; --- SFX 1: Hit (descending pulse beep) ---")
    lines.append("@sfx_1_hit:")
    lines.append("    .byte 4")
    lines.append("    .byte $bf, $00, $a0, $08  ; Pulse 50%, vol 15, mid pitch")
    lines.append("    .byte $bc, $00, $c0, $08  ; Vol 12, lower pitch")
    lines.append("    .byte $b8, $00, $e0, $08  ; Vol 8, lower")
    lines.append("    .byte $b4, $00, $ff, $08  ; Vol 4, lowest")
    lines.append("")
    lines.append("; --- SFX 2: Item pickup (rising pulse arpeggio) ---")
    lines.append("@sfx_2_pickup:")
    lines.append("    .byte 6")
    lines.append("    .byte $bf, $00, $d5, $01  ; C5")
    lines.append("    .byte $bf, $00, $a9, $01  ; E5")
    lines.append("    .byte $bf, $00, $7f, $01  ; G5")
    lines.append("    .byte $bf, $00, $54, $01  ; C6")
    lines.append("    .byte $bc, $00, $54, $01  ; C6 (fade)")
    lines.append("    .byte $b8, $00, $54, $01  ; C6 (fade)")
    lines.append("")
    lines.append("; --- SFX 3: Menu cursor (short high beep) ---")
    lines.append("@sfx_3_menu_cursor:")
    lines.append("    .byte 2")
    lines.append("    .byte $bf, $00, $80, $01  ; Pulse, vol 15, high")
    lines.append("    .byte $b4, $00, $80, $01  ; Fade out")
    lines.append("")

    with open(output_path, 'w') as f:
        f.write('\n'.join(lines) + '\n')
    print(f"Generated: {output_path}")


if __name__ == '__main__':
    if len(sys.argv) < 3:
        print("Usage: generate_placeholder_audio.py <music_output.s> <sfx_output.s>")
        sys.exit(1)

    generate_music_data(sys.argv[1])
    generate_sfx_data(sys.argv[2])
    print("Done.")
