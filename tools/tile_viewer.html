<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>NES Tile Viewer — Zelda 2B Asset Pipeline</title>
<style>
* { margin: 0; padding: 0; box-sizing: border-box; }
body {
    background: #1a1a2e; color: #eee; font-family: 'Courier New', monospace;
    padding: 20px;
}
h1 { color: #e94560; margin-bottom: 10px; font-size: 18px; }
.info { color: #888; font-size: 12px; margin-bottom: 15px; }
.controls {
    display: flex; gap: 15px; align-items: center; margin-bottom: 15px;
    flex-wrap: wrap;
}
.controls label { font-size: 13px; color: #aaa; }
.controls select, .controls input {
    background: #16213e; color: #eee; border: 1px solid #444;
    padding: 4px 8px; font-family: inherit; font-size: 12px;
}
.controls button {
    background: #e94560; color: #fff; border: none; padding: 6px 14px;
    cursor: pointer; font-family: inherit; font-size: 12px;
}
.controls button:hover { background: #c73654; }
#grid-label { color: #888; font-size: 11px; margin-bottom: 5px; }
.canvas-wrap {
    border: 2px solid #333; display: inline-block; background: #000;
    image-rendering: pixelated;
}
canvas { image-rendering: pixelated; display: block; }
#tile-info {
    margin-top: 10px; font-size: 12px; color: #aaa;
    min-height: 20px;
}
.palette-preview {
    display: inline-flex; gap: 2px; margin: 0 5px; vertical-align: middle;
}
.palette-swatch {
    width: 14px; height: 14px; border: 1px solid #555;
}
</style>
</head>
<body>

<h1>NES Tile Viewer</h1>
<div class="info">Drop a .chr file or use the file picker. Hover tiles for index info.</div>

<div class="controls">
    <label>CHR File: <input type="file" id="file-input" accept=".chr,.bin"></label>
    <label>Scale: <select id="scale">
        <option value="1">1x</option>
        <option value="2" selected>2x</option>
        <option value="3">3x</option>
        <option value="4">4x</option>
    </select></label>
    <label>Columns: <input type="number" id="cols" value="16" min="1" max="64" style="width:50px"></label>
    <label>Palette:
        <select id="palette-select">
            <option value="gray">Grayscale</option>
            <option value="green">Zelda Green</option>
            <option value="cave">Cave Blue</option>
            <option value="desert">Desert</option>
            <option value="custom">Custom</option>
        </select>
        <span id="palette-preview" class="palette-preview"></span>
    </label>
    <label id="custom-palette-wrap" style="display:none">
        Colors (NES hex): <input type="text" id="custom-palette" value="0F,29,19,09" style="width:120px">
    </label>
    <button id="btn-render">Re-render</button>
</div>

<div id="grid-label"></div>
<div class="canvas-wrap">
    <canvas id="canvas" width="256" height="256"></canvas>
</div>
<div id="tile-info">No CHR data loaded.</div>

<script>
// NES master palette (64 colors)
const NES_PAL = [
    [84,84,84],[0,30,116],[8,16,144],[48,0,136],
    [68,0,100],[92,0,48],[84,4,0],[60,24,0],
    [32,42,0],[8,58,0],[0,64,0],[0,60,0],
    [0,50,60],[0,0,0],[0,0,0],[0,0,0],
    [152,150,152],[8,76,196],[48,50,236],[92,30,228],
    [136,20,176],[160,20,100],[152,34,32],[120,60,0],
    [84,90,0],[40,114,0],[8,124,0],[0,118,40],
    [0,102,120],[0,0,0],[0,0,0],[0,0,0],
    [236,238,236],[76,154,236],[120,124,236],[176,98,236],
    [228,84,236],[236,88,180],[236,106,100],[212,136,32],
    [160,170,0],[116,196,0],[76,208,32],[56,204,108],
    [56,180,204],[60,60,60],[0,0,0],[0,0,0],
    [236,238,236],[168,204,236],[188,188,236],[212,178,236],
    [236,174,236],[236,174,212],[236,180,176],[228,196,144],
    [204,210,120],[180,222,120],[168,226,144],[152,226,180],
    [160,214,228],[160,162,160],[0,0,0],[0,0,0],
];

const PRESETS = {
    gray: [0x0F, 0x00, 0x10, 0x30],
    green: [0x0F, 0x19, 0x29, 0x30],
    cave: [0x0F, 0x02, 0x12, 0x30],
    desert: [0x0F, 0x17, 0x27, 0x37],
};

let chrData = null;
let tiles = [];

function parseCHR(data) {
    const arr = new Uint8Array(data);
    const count = Math.floor(arr.length / 16);
    const result = [];
    for (let t = 0; t < count; t++) {
        const tile = [];
        const off = t * 16;
        for (let row = 0; row < 8; row++) {
            const rowPx = [];
            const b0 = arr[off + row];
            const b1 = arr[off + 8 + row];
            for (let col = 0; col < 8; col++) {
                const bit = 7 - col;
                const val = ((b0 >> bit) & 1) | (((b1 >> bit) & 1) << 1);
                rowPx.push(val);
            }
            tile.push(rowPx);
        }
        result.push(tile);
    }
    return result;
}

function getPalette() {
    const sel = document.getElementById('palette-select').value;
    let indices;
    if (sel === 'custom') {
        const txt = document.getElementById('custom-palette').value;
        indices = txt.split(',').map(s => parseInt(s.trim(), 16) & 0x3F);
    } else {
        indices = PRESETS[sel];
    }
    while (indices.length < 4) indices.push(0);
    return indices.map(i => NES_PAL[i]);
}

function updatePalettePreview() {
    const colors = getPalette();
    const wrap = document.getElementById('palette-preview');
    wrap.innerHTML = colors.map(c =>
        `<span class="palette-swatch" style="background:rgb(${c[0]},${c[1]},${c[2]})"></span>`
    ).join('');
}

function render() {
    if (!tiles.length) return;
    const scale = parseInt(document.getElementById('scale').value);
    const cols = parseInt(document.getElementById('cols').value);
    const rows = Math.ceil(tiles.length / cols);
    const canvas = document.getElementById('canvas');
    canvas.width = cols * 8 * scale;
    canvas.height = rows * 8 * scale;
    const ctx = canvas.getContext('2d');
    const colors = getPalette();

    const imgData = ctx.createImageData(canvas.width, canvas.height);
    const d = imgData.data;

    for (let idx = 0; idx < tiles.length; idx++) {
        const tile = tiles[idx];
        const tx = (idx % cols) * 8;
        const ty = Math.floor(idx / cols) * 8;
        for (let r = 0; r < 8; r++) {
            for (let c = 0; c < 8; c++) {
                const color = colors[tile[r][c]];
                for (let sy = 0; sy < scale; sy++) {
                    for (let sx = 0; sx < scale; sx++) {
                        const px = ((ty + r) * scale + sy) * canvas.width + (tx + c) * scale + sx;
                        d[px * 4] = color[0];
                        d[px * 4 + 1] = color[1];
                        d[px * 4 + 2] = color[2];
                        d[px * 4 + 3] = 255;
                    }
                }
            }
        }
    }
    ctx.putImageData(imgData, 0, 0);

    document.getElementById('grid-label').textContent =
        `${tiles.length} tiles (${cols}×${rows}), ${tiles.length * 16} bytes, ` +
        `${(tiles.length * 16 / 1024).toFixed(1)} CHR banks`;
}

document.getElementById('file-input').addEventListener('change', e => {
    const file = e.target.files[0];
    if (!file) return;
    const reader = new FileReader();
    reader.onload = ev => {
        chrData = ev.target.result;
        tiles = parseCHR(chrData);
        document.getElementById('tile-info').textContent =
            `Loaded: ${file.name} (${new Uint8Array(chrData).length} bytes, ${tiles.length} tiles)`;
        render();
    };
    reader.readAsArrayBuffer(file);
});

document.getElementById('canvas').addEventListener('mousemove', e => {
    if (!tiles.length) return;
    const canvas = e.target;
    const rect = canvas.getBoundingClientRect();
    const scale = parseInt(document.getElementById('scale').value);
    const cols = parseInt(document.getElementById('cols').value);
    const x = Math.floor((e.clientX - rect.left) / scale / 8);
    const y = Math.floor((e.clientY - rect.top) / scale / 8);
    const idx = y * cols + x;
    if (idx < tiles.length) {
        document.getElementById('tile-info').textContent =
            `Tile #${idx} ($${idx.toString(16).toUpperCase().padStart(2,'0')}) at grid (${x}, ${y}) — ` +
            `CHR offset: $${(idx * 16).toString(16).toUpperCase()}`;
    }
});

document.getElementById('palette-select').addEventListener('change', e => {
    document.getElementById('custom-palette-wrap').style.display =
        e.target.value === 'custom' ? '' : 'none';
    updatePalettePreview();
    render();
});

document.getElementById('btn-render').addEventListener('click', () => {
    updatePalettePreview();
    render();
});

document.getElementById('scale').addEventListener('change', render);
document.getElementById('cols').addEventListener('change', render);

// Drag & drop
document.body.addEventListener('dragover', e => { e.preventDefault(); });
document.body.addEventListener('drop', e => {
    e.preventDefault();
    const file = e.dataTransfer.files[0];
    if (!file) return;
    const reader = new FileReader();
    reader.onload = ev => {
        chrData = ev.target.result;
        tiles = parseCHR(chrData);
        document.getElementById('tile-info').textContent =
            `Loaded: ${file.name} (${new Uint8Array(chrData).length} bytes, ${tiles.length} tiles)`;
        render();
    };
    reader.readAsArrayBuffer(file);
});

updatePalettePreview();
</script>
</body>
</html>
