<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>NES Sprite Viewer â€” Zelda 2B Asset Pipeline</title>
<style>
* { margin: 0; padding: 0; box-sizing: border-box; }
body {
    background: #1a1a2e; color: #eee; font-family: 'Courier New', monospace;
    padding: 20px;
}
h1 { color: #e94560; margin-bottom: 10px; font-size: 18px; }
.info { color: #888; font-size: 12px; margin-bottom: 15px; }
.controls {
    display: flex; gap: 15px; align-items: center; margin-bottom: 15px;
    flex-wrap: wrap;
}
.controls label { font-size: 13px; color: #aaa; }
.controls select, .controls input {
    background: #16213e; color: #eee; border: 1px solid #444;
    padding: 4px 8px; font-family: inherit; font-size: 12px;
}
.controls button {
    background: #e94560; color: #fff; border: none; padding: 6px 14px;
    cursor: pointer; font-family: inherit; font-size: 12px;
}
.controls button:hover { background: #c73654; }
.section { margin-bottom: 20px; }
.section h2 { font-size: 14px; color: #e94560; margin-bottom: 8px; }
.sprite-grid {
    display: flex; flex-wrap: wrap; gap: 8px;
}
.sprite-cell {
    border: 1px solid #333; padding: 4px; background: #111;
    text-align: center;
}
.sprite-cell canvas { image-rendering: pixelated; display: block; margin: 0 auto 4px; }
.sprite-label { font-size: 10px; color: #666; }
.anim-frame { display: inline-block; margin: 0 4px; }
#anim-canvas { image-rendering: pixelated; border: 2px solid #333; background: #000; }
</style>
</head>
<body>

<h1>NES Sprite Viewer</h1>
<div class="info">
    View NES sprites as 16x16 (2x2 tile) arrangements. Load a .chr file and configure the sprite layout.
    Designed for reviewing Link's sprite sheet and enemy sprites.
</div>

<div class="controls">
    <label>CHR File: <input type="file" id="file-input" accept=".chr,.bin"></label>
    <label>Sprite Size:
        <select id="sprite-size">
            <option value="8">8x8 (1 tile)</option>
            <option value="16" selected>16x16 (2x2 tiles)</option>
            <option value="24">24x16 (3x2)</option>
        </select>
    </label>
    <label>Scale:
        <select id="scale">
            <option value="2">2x</option>
            <option value="3" selected>3x</option>
            <option value="4">4x</option>
        </select>
    </label>
    <label>Palette:
        <select id="palette-select">
            <option value="link">Link (green)</option>
            <option value="link-blue">Link (blue ring)</option>
            <option value="link-red">Link (red ring)</option>
            <option value="enemy">Enemy (red)</option>
            <option value="gray">Grayscale</option>
        </select>
    </label>
    <label>BG Color:
        <select id="bg-color">
            <option value="transparent">Transparent</option>
            <option value="black">Black</option>
            <option value="checker">Checkerboard</option>
        </select>
    </label>
</div>

<div class="section">
    <h2>All Sprites</h2>
    <div id="sprite-grid" class="sprite-grid"></div>
</div>

<div class="section">
    <h2>Animation Preview</h2>
    <div class="controls">
        <label>Frames (comma-sep sprite indices): <input type="text" id="anim-frames" value="0,1" style="width:200px"></label>
        <label>FPS: <input type="number" id="anim-fps" value="4" min="1" max="30" style="width:50px"></label>
        <button id="btn-anim">Play</button>
        <button id="btn-stop">Stop</button>
    </div>
    <div style="margin-top: 10px;">
        <canvas id="anim-canvas" width="48" height="48"></canvas>
    </div>
</div>

<script>
const NES_PAL = [
    [84,84,84],[0,30,116],[8,16,144],[48,0,136],
    [68,0,100],[92,0,48],[84,4,0],[60,24,0],
    [32,42,0],[8,58,0],[0,64,0],[0,60,0],
    [0,50,60],[0,0,0],[0,0,0],[0,0,0],
    [152,150,152],[8,76,196],[48,50,236],[92,30,228],
    [136,20,176],[160,20,100],[152,34,32],[120,60,0],
    [84,90,0],[40,114,0],[8,124,0],[0,118,40],
    [0,102,120],[0,0,0],[0,0,0],[0,0,0],
    [236,238,236],[76,154,236],[120,124,236],[176,98,236],
    [228,84,236],[236,88,180],[236,106,100],[212,136,32],
    [160,170,0],[116,196,0],[76,208,32],[56,204,108],
    [56,180,204],[60,60,60],[0,0,0],[0,0,0],
    [236,238,236],[168,204,236],[188,188,236],[212,178,236],
    [236,174,236],[236,174,212],[236,180,176],[228,196,144],
    [204,210,120],[180,222,120],[168,226,144],[152,226,180],
    [160,214,228],[160,162,160],[0,0,0],[0,0,0],
];

const SPRITE_PALETTES = {
    'link':      [0x0F, 0x19, 0x29, 0x30],  // Green Link
    'link-blue': [0x0F, 0x02, 0x12, 0x30],  // Blue ring
    'link-red':  [0x0F, 0x06, 0x16, 0x30],  // Red ring
    'enemy':     [0x0F, 0x06, 0x16, 0x30],  // Red enemy
    'gray':      [0x0F, 0x00, 0x10, 0x30],  // Grayscale
};

let allTiles = [];
let animInterval = null;

function parseCHR(data) {
    const arr = new Uint8Array(data);
    const count = Math.floor(arr.length / 16);
    const result = [];
    for (let t = 0; t < count; t++) {
        const tile = [];
        const off = t * 16;
        for (let row = 0; row < 8; row++) {
            const rowPx = [];
            const b0 = arr[off + row];
            const b1 = arr[off + 8 + row];
            for (let col = 0; col < 8; col++) {
                const bit = 7 - col;
                rowPx.push(((b0 >> bit) & 1) | (((b1 >> bit) & 1) << 1));
            }
            tile.push(rowPx);
        }
        result.push(tile);
    }
    return result;
}

function getColors() {
    const sel = document.getElementById('palette-select').value;
    const indices = SPRITE_PALETTES[sel] || SPRITE_PALETTES.gray;
    return indices.map(i => NES_PAL[i & 0x3F]);
}

function renderTileToCanvas(canvas, tileIndices, tilesWide, tilesHigh, scale, colors, bgMode) {
    const w = tilesWide * 8 * scale;
    const h = tilesHigh * 8 * scale;
    canvas.width = w;
    canvas.height = h;
    const ctx = canvas.getContext('2d');

    // Background
    if (bgMode === 'checker') {
        for (let y = 0; y < h; y++) {
            for (let x = 0; x < w; x++) {
                const c = ((Math.floor(x/4) + Math.floor(y/4)) % 2) ? '#222' : '#333';
                ctx.fillStyle = c;
                ctx.fillRect(x, y, 1, 1);
            }
        }
    } else if (bgMode === 'black') {
        ctx.fillStyle = '#000';
        ctx.fillRect(0, 0, w, h);
    } else {
        ctx.clearRect(0, 0, w, h);
    }

    const imgData = ctx.getImageData(0, 0, w, h);
    const d = imgData.data;

    for (let ti = 0; ti < tileIndices.length; ti++) {
        const tileIdx = tileIndices[ti];
        if (tileIdx >= allTiles.length) continue;
        const tile = allTiles[tileIdx];
        const ox = (ti % tilesWide) * 8;
        const oy = Math.floor(ti / tilesWide) * 8;
        for (let r = 0; r < 8; r++) {
            for (let c = 0; c < 8; c++) {
                const pv = tile[r][c];
                if (pv === 0 && bgMode === 'transparent') continue;
                const color = colors[pv];
                for (let sy = 0; sy < scale; sy++) {
                    for (let sx = 0; sx < scale; sx++) {
                        const px = ((oy + r) * scale + sy) * w + (ox + c) * scale + sx;
                        d[px * 4] = color[0];
                        d[px * 4 + 1] = color[1];
                        d[px * 4 + 2] = color[2];
                        d[px * 4 + 3] = 255;
                    }
                }
            }
        }
    }
    ctx.putImageData(imgData, 0, 0);
}

function getSpriteConfig() {
    const size = document.getElementById('sprite-size').value;
    if (size === '8')  return { tw: 1, th: 1 };
    if (size === '16') return { tw: 2, th: 2 };
    if (size === '24') return { tw: 3, th: 2 };
    return { tw: 2, th: 2 };
}

function renderAll() {
    if (!allTiles.length) return;
    const grid = document.getElementById('sprite-grid');
    grid.innerHTML = '';
    const scale = parseInt(document.getElementById('scale').value);
    const colors = getColors();
    const bgMode = document.getElementById('bg-color').value;
    const { tw, th } = getSpriteConfig();
    const tilesPerSprite = tw * th;
    const numSprites = Math.floor(allTiles.length / tilesPerSprite);

    for (let si = 0; si < numSprites; si++) {
        const cell = document.createElement('div');
        cell.className = 'sprite-cell';
        const canvas = document.createElement('canvas');
        const tileIndices = [];
        for (let i = 0; i < tilesPerSprite; i++) {
            tileIndices.push(si * tilesPerSprite + i);
        }
        renderTileToCanvas(canvas, tileIndices, tw, th, scale, colors, bgMode);
        cell.appendChild(canvas);
        const label = document.createElement('div');
        label.className = 'sprite-label';
        label.textContent = `#${si} (tiles ${si*tilesPerSprite}-${si*tilesPerSprite+tilesPerSprite-1})`;
        cell.appendChild(label);
        grid.appendChild(cell);
    }
}

document.getElementById('file-input').addEventListener('change', e => {
    const file = e.target.files[0];
    if (!file) return;
    const reader = new FileReader();
    reader.onload = ev => {
        allTiles = parseCHR(ev.target.result);
        renderAll();
    };
    reader.readAsArrayBuffer(file);
});

['sprite-size', 'scale', 'palette-select', 'bg-color'].forEach(id => {
    document.getElementById(id).addEventListener('change', renderAll);
});

document.getElementById('btn-anim').addEventListener('click', () => {
    if (animInterval) clearInterval(animInterval);
    const { tw, th } = getSpriteConfig();
    const tilesPerSprite = tw * th;
    const frameStr = document.getElementById('anim-frames').value;
    const frames = frameStr.split(',').map(s => parseInt(s.trim())).filter(n => !isNaN(n));
    if (!frames.length) return;
    const fps = parseInt(document.getElementById('anim-fps').value) || 4;
    const scale = parseInt(document.getElementById('scale').value);
    const colors = getColors();
    const bgMode = document.getElementById('bg-color').value;
    const canvas = document.getElementById('anim-canvas');
    let fi = 0;
    const draw = () => {
        const si = frames[fi % frames.length];
        const tileIndices = [];
        for (let i = 0; i < tilesPerSprite; i++) {
            tileIndices.push(si * tilesPerSprite + i);
        }
        renderTileToCanvas(canvas, tileIndices, tw, th, scale, colors, bgMode);
        fi++;
    };
    draw();
    animInterval = setInterval(draw, 1000 / fps);
});

document.getElementById('btn-stop').addEventListener('click', () => {
    if (animInterval) { clearInterval(animInterval); animInterval = null; }
});

// Drag & drop
document.body.addEventListener('dragover', e => e.preventDefault());
document.body.addEventListener('drop', e => {
    e.preventDefault();
    const file = e.dataTransfer.files[0];
    if (!file) return;
    const reader = new FileReader();
    reader.onload = ev => {
        allTiles = parseCHR(ev.target.result);
        renderAll();
    };
    reader.readAsArrayBuffer(file);
});
</script>
</body>
</html>
